/// @file

#define INTEROP       true                                                                          // "true" = use OpenGL-OpenCL interoperability.
#define SX            800                                                                           // Window x-size [px].
#define SY            600                                                                           // Window y-size [px].
#define NM            "Neutrino - Vacuum decay"                                                     // Window name.
#define OX            0.0f                                                                          // x-axis orbit initial rotation.
#define OY            0.0f                                                                          // y-axis orbit initial rotation.
#define PX            0.0f                                                                          // x-axis pan initial translation.
#define PY            0.0f                                                                          // y-axis pan initial translation.
#define PZ            -2.0f                                                                         // z-axis pan initial translation.

#define SURFACE_TAG   1                                                                             // Surface tag.
#define BORDER_TAG    9                                                                             // Border tag.
#define SIDE_X_TAG    10                                                                            // Side "x" tag.
#define SIDE_Y_TAG    11                                                                            // Side "y" tag.
#define CURVE_DIM     1                                                                             // Curve dimension.
#define SURFACE_DIM   2                                                                             // Surface dimension.
#define BORDER_DIM    1                                                                             // Border dimension.
#define SIDE_X_DIM    1                                                                             // Side "x" dimension.
#define SIDE_Y_DIM    1                                                                             // Side "y" dimension.
#define DS            0.05f                                                                         // vacuum elementary cell side.
#define EPSILON       0.01f                                                                         // Tolerance for cell detection.
#define CELL_VERTICES 4                                                                             // Number of vertices per elementary cell.

#define M_MAX         100                                                                           // Maximum allowed number of rejections.
#define K_INIT        0.5f                                                                          // Radial parameter.
#define C1_INIT       1.0f                                                                          // c_1 parameter.
#define C2_INIT       -2.1f                                                                         // c_2 parameter.
#define LAMBDA_INIT   1.0f                                                                          // lambda parameter.
#define MU_INIT       0.0f                                                                          // mu parameter.
#define T_INIT        1.0f                                                                          // T parameter.
#define T_HAT_INIT    0.08f                                                                         // T_hat parameter.
#define PHI_INIT      0.0f                                                                          // phi parameter.
#define PHI_MAX_INIT  1.5f                                                                          // phi_max parameter.
#define ALPHA_INIT    1.0f                                                                          // Radial exponent.
#define TRIALS_INIT   100                                                                           // Auto-trials.
#define DATA_POINTS   100                                                                           // Data points for energy profile.

#ifdef __linux__
  #define SHADER_HOME "../../Code/shader/"                                                          // Linux OpenGL shaders directory.
  #define KERNEL_HOME "../../Code/kernel/"                                                          // Linux OpenCL kernels directory.
  #define GMSH_HOME   "../../Code/mesh/"                                                            // Linux GMSH mesh directory.
  #define LOG_HOME    "../../log/"                                                                  // Linux log directory.
  #define DLOAD_HOME  "../../log/"                                                                  // Linux log directory.
  #define ULOAD_HOME  "../../log/"                                                                  // Linux log directory.
#endif

#ifdef WIN32
  #define SHADER_HOME "..\\..\\Code\\shader\\"                                                      // Windows OpenGL shaders directory.
  #define KERNEL_HOME "..\\..\\Code\\kernel\\"                                                      // Windows OpenCL kernels directory.
  #define GMSH_HOME   "..\\..\\Code\\mesh\\"                                                        // Windows GMSH mesh directory.
  #define LOG_HOME    "..\\..\\log\\"                                                               // Windows log directory.
  #define DLOAD_HOME  "..\\..\\log\\"                                                               // Windows log directory.
  #define ULOAD_HOME  "..\\..\\log\\"                                                               // Windows log directory.
#endif

#define SHADER_VERT   "voxel_vertex.vert"                                                           // OpenGL vertex shader.
#define SHADER_GEOM   "voxel_geometry.geom"                                                         // OpenGL geometry shader.
#define SHADER_FRAG   "voxel_fragment.frag"                                                         // OpenGL fragment shader.
#define KERNEL_0      "thekernel_0.cl"                                                              // OpenCL kernel source.
#define KERNEL_1      "thekernel_1.cl"                                                              // OpenCL kernel source.
#define KERNEL_2      "thekernel_2.cl"                                                              // OpenCL kernel source.
#define KERNEL_3      "thekernel_3.cl"                                                              // OpenCL kernel source.
#define UTILITIES     "utilities.cl"                                                                // OpenCL utilities source.
#define MESH_FILE     "Periodic_square.msh"                                                         // GMSH mesh.
#define MESH          GMSH_HOME MESH_FILE                                                           // GMSH mesh (full path).
#define LOG_FILE      "Data"                                                                        // Log file name.
#define LOG_HEAD      "Vacuum decay."                                                               // Log file header.
#define LOG_EXT       "dat"                                                                         // Log file extension.
#define LOG           LOG_HOME LOG_FILE                                                             // Log file name (full name, timestamp and extension to be added).
#define DLOAD_FILE    "Download_"                                                                   // Download file name.
#define DLOAD_HEAD    "Vacuum decay."                                                               // Download file header.
#define DLOAD_EXT     "dat"                                                                         // Download file extension.
#define DLOAD         DLOAD_HOME DLOAD_FILE                                                         // Download file name (full name, timestamp and extension to be added).
#define ULOAD_FILE    "Upload"                                                                      // Upload file name.
#define ULOAD_HEAD    "Vacuum decay."                                                               // Upload file header.
#define ULOAD_EXT     "dat"                                                                         // Upload file extension.
#define ULOAD         ULOAD_HOME ULOAD_FILE                                                         // Upload file name (full name, timestamp and extension to be added).


// INCLUDES:
#include "nu.hpp"                                                                                   // Neutrino's header file.

int main ()
{
  // TIMESTAMP:
  std::string         timestamp;                                                                    // Timestamp.

  // INDICES:
  size_t              i;                                                                            // Index [#].
  size_t              j;                                                                            // Index [#].
  size_t              j_min;                                                                        // Index [#].
  size_t              j_max;                                                                        // Index [#].
  unsigned int        time_index;                                                                   // Index [#].
  unsigned int        trial_index;                                                                  // Index [#].
  std::string         trial_text;                                                                   // Trial text, corresponding to trial index.
  int                 trials;                                                                       // Index [#].
  int                 trials_new;                                                                   // Index [#].
  bool                savedata;                                                                     // Save data flag.

  // SEED:
  unsigned int        seed;                                                                         // Seed for C++ rand().

  // MOUSE PARAMETERS:
  float               ms_orbit_rate   = 1.0f;                                                       // Orbit rotation rate [rev/s].
  float               ms_pan_rate     = 5.0f;                                                       // Pan translation rate [m/s].
  float               ms_decaytime    = 1.25f;                                                      // Pan LP filter decay time [s].

  // GAMEPAD PARAMETERS:
  float               gmp_orbit_rate  = 1.0f;                                                       // Orbit angular rate coefficient [rev/s].
  float               gmp_pan_rate    = 1.0f;                                                       // Pan translation rate [m/s].
  float               gmp_decaytime   = 1.25f;                                                      // Low pass filter decay time [s].
  float               gmp_deadzone    = 0.30f;                                                      // Gamepad joystick deadzone [0...1].

  // OPENGL:
  nu::opengl*         gl              = new nu::opengl (NM, SX, SY, OX, OY, PX, PY, PZ);            // OpenGL context.
  nu::shader*         S               = new nu::shader ();                                          // OpenGL shader program.
  nu::projection_mode pmode           = nu::MONOCULAR;                                              // OpenGL projection mode.
  nu::view_mode       vmode           = nu::DIRECT;                                                 // OpenGL view mode.

  // OPENCL:
  nu::opencl*         cl              = new nu::opencl (nu::GPU);                                   // OpenCL context.
  nu::kernel*         K0              = new nu::kernel ();                                          // OpenCL kernel array.
  nu::kernel*         K1              = new nu::kernel ();                                          // OpenCL kernel array.
  nu::kernel*         K2              = new nu::kernel ();                                          // OpenCL kernel array.
  nu::kernel*         K3              = new nu::kernel ();                                          // OpenCL kernel array.
  nu::float4*         color           = new nu::float4 (0);                                         // Color [].
  nu::float4*         position        = new nu::float4 (1);                                         // Position [m].
  nu::int1*           central         = new nu::int1 (2);                                           // Central nodes.
  nu::int1*           neighbour       = new nu::int1 (3);                                           // Neighbour.
  nu::int1*           offset          = new nu::int1 (4);                                           // Offset.
  nu::float1*         phi             = new nu::float1 (5);                                         // phi.
  nu::float1*         phi_int         = new nu::float1 (6);                                         // phi (intermediate value).
  nu::int4*           state_phi       = new nu::int4 (7);                                           // Random generator state.
  nu::int4*           state_threshold = new nu::int4 (8);                                           // Random generator state.
  nu::float1*         phi_row_sum     = new nu::float1 (9);                                         // phi row summation.
  nu::float1*         phi2_row_sum    = new nu::float1 (10);                                        // phi square row summation.
  nu::int1*           m_overflow      = new nu::int1 (11);                                          // Rejection sampling overflow.
  nu::int1*           m_overflow_sum  = new nu::int1 (12);                                          // Rejection sampling overflow sum.
  nu::float1*         parameter       = new nu::float1 (13);                                        // Parameters array.

  // IMGUI:
  nu::imgui*          hud             = new nu::imgui ();                                           // ImGui context.

  // MESH:
  nu::mesh*           vacuum          = new nu::mesh (MESH);                                        // False vacuum domain.
  size_t              nodes;                                                                        // Number of nodes.
  size_t              elements;                                                                     // Number of elements.
  size_t              groups;                                                                       // Number of groups.
  size_t              neighbours;                                                                   // Number of neighbours.
  std::vector<size_t> side_x;                                                                       // Nodes on "x" side.
  std::vector<size_t> side_y;                                                                       // Nodes on "y" side.
  std::vector<GLint>  border;                                                                       // Nodes on border.
  size_t              side_x_nodes;                                                                 // Number of nodes in "x" direction [#].
  size_t              side_y_nodes;                                                                 // Number of nodes in "x" direction [#].
  size_t              border_nodes;                                                                 // Number of border nodes.
  float               x_min      = -1.0f;                                                           // "x_min" spatial boundary [m].
  float               x_max      = +1.0f;                                                           // "x_max" spatial boundary [m].
  float               y_min      = -1.0f;                                                           // "y_min" spatial boundary [m].
  float               y_max      = +1.0f;                                                           // "y_max" spatial boundary [m].
  float               dx;                                                                           // x-axis mesh spatial size [m].
  float               dy;                                                                           // y-axis mesh spatial size [m].

  // SIMULATION VARIABLES:
  float               phi_start  = PHI_INIT;                                                        // phi parameter.
  float               phi_max    = PHI_MAX_INIT;                                                    // phi_max.
  float               K          = K_INIT;                                                          // Radial parameter.
  float               alpha      = ALPHA_INIT;                                                      // Radial exponent.
  float               c_1        = C1_INIT;                                                         // c_1 parameter.
  float               c_2        = C2_INIT;                                                         // c_2 parameter.
  float               mu         = MU_INIT;                                                         // mu parameter.
  float               lambda     = LAMBDA_INIT;                                                     // lambda parameter.
  float               T          = T_INIT;                                                          // T parameter.
  float               T_hat      = T_HAT_INIT;                                                      // T_hat parameter.
  float               m_max      = M_MAX;                                                           // Maximum allowed number of rejections.
  float               columns;                                                                      // Numbers of data columns.
  float               ds;                                                                           // Simulation space step [m].
  float               dt;                                                                           // Simulation time step [s].
  float               phi_avg    = 0.0f;                                                            // Average phi.
  float               phi_stderr = 0.0f;                                                            // Standard error phi.
  float               m_level    = 0.0f;                                                            // Rejection sampling overflow level.

  // ENERGY PROFILE VARIABLES:
  std::vector<float>  data_x;
  std::vector<float>  data_y;
  float               data_phi   = 0;
  float               data_V     = 0;

  // DATA LOG:
  nu::logfile*        log        = new nu::logfile ();                                              // Log file.

  // DATA DOWNLOAD:
  nu::logfile*        download   = new nu::logfile ();                                              // Download file.

  // DATA UPLOAD;
  nu::logfile*        upload     = new nu::logfile ();                                              // Upload file.
  std::vector<int>    upload_i;
  std::vector<float>  upload_x;
  std::vector<float>  upload_y;
  std::vector<float>  upload_phi;


  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////// DATA INITIALIZATION //////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // MESH "X" SIDE:
  vacuum->process (SIDE_X_TAG, SIDE_X_DIM, nu::MSH_PNT);                                            // Processing mesh...
  side_x_nodes    = vacuum->node.size ();                                                           // Getting number of nodes along "x" side...

  // MESH "Y" SIDE:
  vacuum->process (SIDE_Y_TAG, SIDE_Y_DIM, nu::MSH_PNT);                                            // Processing mesh...
  side_y_nodes    = vacuum->node.size ();                                                           // Getting number of nodes along "y" side...

  // COMPUTING PHYSICAL PARAMETERS:
  dx              = (x_max - x_min)/(side_x_nodes - 1);                                             // x-axis mesh spatial size [m].
  dy              = (y_max - y_min)/(side_y_nodes - 1);                                             // y-axis mesh spatial size [m].
  ds              = dx;                                                                             // Setting space step [m].
  dt              = 0.0f;                                                                           // Resetting time step [s].

  // COMPUTING DATA PROPERTIES:
  columns         = (float)side_x_nodes;                                                            // Setting numbers od data columns...

  // MESH SURFACE:
  vacuum->process (SURFACE_TAG, SURFACE_DIM, nu::MSH_QUA_4);                                        // Processing mesh...
  position->data  = vacuum->node_coordinates;                                                       // Setting all node coordinates...
  neighbour->data = vacuum->neighbour;                                                              // Setting neighbour indices...
  offset->data    = vacuum->neighbour_offset;                                                       // Setting neighbour offsets...
  nodes           = vacuum->node.size ();                                                           // Getting the number of nodes...
  elements        = vacuum->element.size ();                                                        // Getting the number of elements...
  groups          = vacuum->group.size ();                                                          // Getting the number of groups...
  neighbours      = vacuum->neighbour.size ();                                                      // Getting the number of neighbours...
  std::cout << "nodes = " << nodes << std::endl;                                                    // Printing message...
  std::cout << "elements = " << elements/CELL_VERTICES << std::endl;                                // Printing message...
  std::cout << "groups = " << groups/CELL_VERTICES << std::endl;                                    // Printing message...
  std::cout << "neighbours = " << neighbours << std::endl;                                          // Printing message...

  // SETTING RANDOM SEED:
  seed            = (unsigned int)time (NULL);                                                      // Generating seed for C++ rand()...
  srand (seed);                                                                                     // Setting C++ rand() seed...

  // SETTING NEUTRINO ARRAYS ("surface" depending):
  for(i = 0; i < nodes; i++)
  {
    std::cout << "i = " << i << ", node index = " << vacuum->node[i] << ", neighbour indices:";     // Printing message...
    state_phi->data.push_back ({rand (), rand (), rand (), rand ()});                               // Setting state_sz seed...
    state_threshold->data.push_back ({rand (), rand (), rand (), rand ()});                         // Setting state_th seed...
    color->data.push_back ({0.0f, 1.0f, 0.0f, 1.0f});                                               // Setting node color...
    phi->data.push_back (phi_start);                                                                // Setting initial phi...
    upload_i.push_back (i);                                                                         // Setting initial index...
    upload_x.push_back (position->data[i].x);                                                       // Setting initial x...
    upload_y.push_back (position->data[i].y);                                                       // Setting initial x...
    upload_phi.push_back (phi_start);                                                               // Setting initial phi...
    phi_int->data.push_back (phi_start);                                                            // Setting initial phi (intermediate value)...
    m_overflow->data.push_back (0);                                                                 // Resetting rejection sampling overflow...

    // Computing minimum element offset index:
    if(i == 0)
    {
      j_min = 0;                                                                                    // Setting minimum element offset index...
    }
    else
    {
      j_min = offset->data[i - 1];                                                                  // Setting minimum element offset index...
    }

    j_max = offset->data[i];                                                                        // Setting maximum element offset index...

    for(j = j_min; j < j_max; j++)
    {
      central->data.push_back (vacuum->node[i]);                                                    // Building central node tuple...

      std::cout << " " << neighbour->data[j];                                                       // Printing message...
    }

    std::cout << std::endl;                                                                         // Printing message...
  }

  for(i = 0; i < side_y_nodes; i++)
  {
    phi_row_sum->data.push_back (0.0f);                                                             // Resetting phi row summation...
    phi2_row_sum->data.push_back (0.0f);                                                            // Resetting phi square row summation...
    m_overflow_sum->data.push_back (0);                                                             // Resetting rejection sampling overflow sum...
  }

  // MESH BORDER:
  vacuum->process (BORDER_TAG, BORDER_DIM, nu::MSH_PNT);                                            // Processing mesh...
  border       = vacuum->node;                                                                      // Getting nodes on border...
  border_nodes = border.size ();                                                                    // Getting the number of nodes on border...

  // SETTING NEUTRINO ARRAYS ("border" depending):
  for(i = 0; i < border_nodes; i++)
  {
    // Doing nothing!
  }

  // SETTING INITIAL PARAMETERS:
  parameter->data.push_back (phi_max);                                                              // Setting phi_max parameter...
  parameter->data.push_back (K);                                                                    // Setting radial parameter...
  parameter->data.push_back (alpha);                                                                // Setting radial exponent...
  parameter->data.push_back (c_1);                                                                  // Setting c_1 parameter...
  parameter->data.push_back (c_2);                                                                  // Setting c_2 parameter...
  parameter->data.push_back (mu);                                                                   // Setting mu parameter...
  parameter->data.push_back (lambda);                                                               // Setting lambda parameter...
  parameter->data.push_back (T);                                                                    // Setting T parameter...
  parameter->data.push_back (T_hat);                                                                // Setting T_hat parameter...
  parameter->data.push_back (m_max);                                                                // Setting maximum allowed number of rejections...
  parameter->data.push_back (columns);                                                              // Setting number of mesh columns...
  parameter->data.push_back (dx);                                                                   // Setting mesh side...
  parameter->data.push_back (dt);                                                                   // Setting simulation time step...

  // SETTING INITIAL ENERGY PROFILE:
  data_phi = 0.0f;

  for(i = 0; i < DATA_POINTS; i++)
  {
    data_x.push_back (data_phi);
    data_V    = (float)(
                        (-pow (mu, 2) + c_1*pow (T, 2))*pow (data_phi, 2) +
                        c_2*T*pow (data_phi, 3) +
                        lambda*pow (data_phi, 4)
                       );
    data_y.push_back (data_V);
    data_phi += phi_max/(DATA_POINTS - 1);
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// OPENCL KERNELS INITIALIZATION /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  K0->addsource (std::string (KERNEL_HOME) + std::string (UTILITIES));                              // Setting kernel source file...
  K0->addsource (std::string (KERNEL_HOME) + std::string (KERNEL_0));                               // Setting kernel source file...
  K0->build (nodes, 0, 0);                                                                          // Building kernel program...
  K1->addsource (std::string (KERNEL_HOME) + std::string (UTILITIES));                              // Setting kernel source file...
  K1->addsource (std::string (KERNEL_HOME) + std::string (KERNEL_1));                               // Setting kernel source file...
  K1->build (nodes, 0, 0);                                                                          // Building kernel program...
  K2->addsource (std::string (KERNEL_HOME) + std::string (UTILITIES));                              // Setting kernel source file...
  K2->addsource (std::string (KERNEL_HOME) + std::string (KERNEL_2));                               // Setting kernel source file...
  K2->build (nodes, 0, 0);                                                                          // Building kernel program...
  K3->addsource (std::string (KERNEL_HOME) + std::string (UTILITIES));                              // Setting kernel source file...
  K3->addsource (std::string (KERNEL_HOME) + std::string (KERNEL_3));                               // Setting kernel source file...
  K3->build (side_y_nodes, 0, 0);                                                                   // Building kernel program...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// OPENGL SHADERS INITIALIZATION /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  S->addsource (std::string (SHADER_HOME) + std::string (SHADER_VERT), nu::VERTEX);                 // Setting shader source file...
  S->addsource (std::string (SHADER_HOME) + std::string (SHADER_GEOM), nu::GEOMETRY);               // Setting shader source file...
  S->addsource (std::string (SHADER_HOME) + std::string (SHADER_FRAG), nu::FRAGMENT);               // Setting shader source file...
  S->build (nodes);                                                                                 // Building shader program...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////// SETTING OPENCL KERNEL ARGUMENTS /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  cl->write ();                                                                                     // Writing OpenCL data...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////// CHARGING RANDOM GENERATORS and DISPLAYING INITIAL VALUES ////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  cl->acquire ();                                                                                   // Acquiring OpenCL kernel...
  cl->execute (K0, nu::WAIT);                                                                       // Executing OpenCL kernel...
  cl->execute (K2, nu::WAIT);                                                                       // Executing OpenCL kernel...
  cl->release ();                                                                                   // Releasing OpenCL kernel...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////// OPENING DATA LOG FILE //////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  timestamp   = cl->get_timestamp ();                                                               // Getting timestamp...
  savedata    = false;                                                                              // Resetting save data flag...
  time_index  = 0;                                                                                  // Resetting time index...
  trial_index = 0;                                                                                  // Resetting trial index...
  trial_text  = std::string ("_#") + std::to_string (trial_index);                                  // Updating trial text...
  trials      = TRIALS_INIT;                                                                        // Setting auto-trial number...
  trials_new  = trials;                                                                             // Setting auto-trial number (new index)...
  log->open (LOG + timestamp, LOG_EXT, LOG_HEAD, "\t", nu::WRITE);                                  // Opening data log file...
  log->write ("#time");                                                                             // Logging header...
  log->write ("#sz_avg");                                                                           // Logging header...
  log->write ("#sz_stderr");                                                                        // Logging header...
  log->write ("#m_level");                                                                          // Logging header...
  log->write ("#trial");                                                                            // Logging header...
  log->endline ();                                                                                  // Logging header...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////// APPLICATION LOOP ////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  while(!gl->closed ())                                                                             // Opening window...
  {
    cl->get_tic ();                                                                                 // Getting "tic" [us]...

    if(dt > 0.0f)
    {
      cl->acquire ();                                                                               // Acquiring OpenCL kernel...
      cl->execute (K1, nu::WAIT);                                                                   // Executing OpenCL kernel...
      cl->execute (K2, nu::WAIT);                                                                   // Executing OpenCL kernel...
      cl->execute (K3, nu::WAIT);                                                                   // Executing OpenCL kernel...
      cl->release ();                                                                               // Releasing OpenCL kernel...
      cl->read (9);                                                                                 // Reading phi_row_sum...
      cl->read (10);                                                                                // Reading phi2_row_sum...
      cl->read (12);                                                                                // Reading m_overflow_sum...

      phi_avg    = 0.0f;                                                                            // Resetting phi average...
      phi_stderr = 0.0f;                                                                            // Resetting phi standard error...
      m_level    = 0.0f;                                                                            // Resetting m_level...

      for(i = 0; i < side_y_nodes; i++)
      {
        phi_avg    += phi_row_sum->data[i];                                                         // Summating phi_row_sum by columns...
        phi_stderr += phi2_row_sum->data[i];                                                        // Summating phi2_row_sum by columns...
        m_level    += m_overflow_sum->data[i];                                                      // Summating m_overflow_sum by columns...
      }

      phi_avg   /= nodes;                                                                           // Computing phi average...
      phi_stderr = (float)sqrt (phi_stderr/nodes - pow (phi_avg, 2))/(float)sqrt (nodes);           // Computing phi standard deviation...
      m_level    = 100.0f*(m_level/nodes);                                                          // Computing rejection sampling overflow level...

      log->write (time_index);                                                                      // Logging data...
      log->write (phi_avg);                                                                         // Logging data...
      log->write (phi_stderr);                                                                      // Logging data...
      log->write (m_level);                                                                         // Logging data...
      log->write (trial_index);                                                                     // Logging data...
      log->endline ();                                                                              // Ending log line...

      time_index++;                                                                                 // Updating time_index...
    }

    if(time_index >= trials_new)
    {
      savedata = true;                                                                              // Setting save data flag...
    }

    gl->begin ();                                                                                   // Beginning gl...
    gl->poll_events ();                                                                             // Polling gl events...
    gl->mouse_navigation (ms_orbit_rate, ms_pan_rate, ms_decaytime);                                // Polling mouse...
    gl->gamepad_navigation (gmp_orbit_rate, gmp_pan_rate, gmp_decaytime, gmp_deadzone);             // Polling gamepad...
    gl->plot (S, pmode, vmode);                                                                     // Plotting shared arguments...

    hud->begin ();                                                                                  // Beginning HUD...
    hud->window ("FALSE VACUUM PARAMETERS:", 200);                                                  // Creating window...
    hud->input ("phi_start:                         ", "[]    ", "phi_start", &phi_start);          // phi_start parameter...
    hud->input ("phi_max:                           ", "[]    ", "phi_max", &phi_max);              // phi_max parameter...
    hud->input ("K:                                 ", "[]    ", "K", &K);                          // K parameter...
    hud->input ("alpha:                             ", "[]    ", "alpha", &alpha);                  // alpha parameter...
    hud->input ("c_1:                               ", "[]    ", "c_1", &c_1);                      // c_1 parameter...
    hud->input ("c_2:                               ", "[]    ", "c_2", &c_2);                      // c_2 parameter...
    hud->input ("mu:                                ", "[]    ", "mu", &mu);                        // mu parameter...
    hud->input ("lambda:                            ", "[]    ", "lambda", &lambda);                // lambda parameter...
    hud->input ("T:                                 ", "[]    ", "T", &T);                          // T parameter...
    hud->input ("T_hat:                             ", "[]    ", "T_hat", &T_hat);                  // T_hat parameter...
    hud->input ("Maximum rejections:                ", "[]    ", "m_max", &m_max);                  // Maximum rejections...
    hud->input ("Auto-restart trials:               ", "[]    ", "trials", &trials);                // Maximum rejections...

    if(trials < TRIALS_INIT)
    {
      trials = TRIALS_INIT;                                                                         // Justifying trials...
    }

    if(hud->button ("[U]pdate", 100) || gl->key_U)
    {
      // UPDATING PHYSICAL PARAMETERS:
      parameter->data[0]  = phi_max;                                                                // Setting phi_max parameter...
      parameter->data[1]  = K;                                                                      // Setting K parameter...
      parameter->data[2]  = alpha;                                                                  // Setting radial exponent...
      parameter->data[3]  = c_1;                                                                    // Setting c_1 parameter...
      parameter->data[4]  = c_2;                                                                    // Setting c_2 parameter...
      parameter->data[5]  = mu;                                                                     // Setting mu parameter...
      parameter->data[6]  = lambda;                                                                 // Setting lambda parameter...
      parameter->data[7]  = T;                                                                      // Setting T parameter...
      parameter->data[8]  = T_hat;                                                                  // Setting T_hat parameter...
      parameter->data[9]  = m_max;                                                                  // Setting maximum allowed number of rejections...
      parameter->data[10] = columns;                                                                // Setting number of mesh columns...
      parameter->data[11] = ds;                                                                     // Setting mesh side...
      parameter->data[12] = dt;                                                                     // Setting simulation time step...
      cl->write (13);                                                                               // Updating all parameters...

      trials_new          = trials;                                                                 // Updating trials...

      // Setting theta for all nodes:
      for(i = 0; i < nodes; i++)
      {
        upload_phi[i] = phi_start;                                                                  // Setting initial theta...
      }

      // UPDATING ENERGY PROFILE:
      data_phi            = 0.0f;

      for(i = 0; i < DATA_POINTS; i++)
      {
        data_x[i] = data_phi;
        data_V    = (float)(
                            (-pow (mu, 2) + c_1*pow (T, 2))*pow (data_phi, 2) +
                            c_2*T*pow (data_phi, 3) +
                            lambda*pow (data_phi, 4)
                           );
        data_y[i] = data_V;
        data_phi += phi_max/(DATA_POINTS - 1);
      }
    }

    hud->finish ();                                                                                 // Finishing window...

    hud->window ("SIMULATION CONTROL:", 200);                                                       // Creating window...
    hud->timeplot (0, 0.1f*dt, phi_avg, phi_stderr, "Higgs field", "[]", "<phi>", "stderr(phi)");   // Plotting average phi and its standard error...
    hud->timeplot (1, 0.1f*dt, m_level, 0.0f, "Rejections", "[%]", "m_level", "");                  // Plotting m_level...
    hud->lineplot (0, data_x, data_y, "Potential energy", "phi", "V", "V(phi)");                    // Plotting potential energy profile...

    if(hud->button ("[S]tart", 100) || gl->key_S)
    {
      dt = 1.0f;                                                                                    // Setting time step [s].
    }

    hud->space (50);                                                                                // Adding space...

    if(hud->button ("[P]ause", 100) || gl->key_P)
    {
      dt = 0.0f;                                                                                    // Setting time step [s].
    }

    hud->space (50);                                                                                // Adding space...

    if(hud->button ("[R]eset", 100) || gl->key_R)
    {
      // Resetting phi for all nodes:
      for(i = 0; i < nodes; i++)
      {
        phi->data[i]     = phi_start;                                                               // Setting initial phi...
        phi_int->data[i] = 0.0f;                                                                    // Setting initial phi (intermediate value)...
      }

      cl->write (5);                                                                                // Updating phi...
      cl->write (6);                                                                                // Updating phi (intermediate)...
      cl->acquire ();                                                                               // Acquiring OpenCL kernel...
      cl->execute (K2, nu::WAIT);                                                                   // Executing OpenCL kernel...
      cl->release ();                                                                               // Releasing OpenCL kernel...
    }

    if(hud->button ("[M]onocular", 100) || gl->key_M)
    {
      pmode = nu::MONOCULAR;                                                                        // Setting monocular projection...
    }

    hud->space (50);                                                                                // Adding space...

    if(hud->button ("[B]inocular", 100) || gl->key_B)
    {
      pmode = nu::BINOCULAR;                                                                        // Setting binocular projection...
    }

    hud->space (50);                                                                                // Adding space...

    if(hud->button ("[E]xit", 100) || gl->key_E)
    {
      gl->close ();                                                                                 // Closing gl...
    }

    if(dt == 0)
    {
      if(hud->button ("[D]ownload", 100) || gl->key_D)
      {

        cl->read (5);                                                                               // Reading phi...

        trial_index++;                                                                              // Updating trial_index...
        trial_text = std::string ("_#") + std::to_string (trial_index);                             // Updating trial text...
        time_index = 0;                                                                             // Resetting time_index...

        download->open (DLOAD + timestamp + trial_text, DLOAD_EXT, DLOAD_HEAD, "\t", nu::WRITE);    // Opening data log file...
        download->write ("#index");                                                                 // Logging header...
        download->write ("#x");                                                                     // Logging header...
        download->write ("#y");                                                                     // Logging header...                                                                  // Logging header...
        download->write ("#phi(x,y)");                                                              // Logging header...
        download->endline ();                                                                       // Logging header...


        for(i = 0; i < nodes; i++)
        {
          download->write (vacuum->node[i]);                                                        // Logging node index...
          download->write (vacuum->node_coordinates[i].x);                                          // Logging node x-coordinate...
          download->write (vacuum->node_coordinates[i].y);                                          // Logging node y-coordinate...
          download->write (phi->data[i]);                                                           // Logging phi(x,y)...
          download->endline ();                                                                     // Ending log line...
        }

        download->close (nu::WRITE);                                                                // Closing data download file...
      }

      hud->space (50);                                                                              // Adding space...

      if(hud->button ("[U]pload", 100) || gl->key_D)
      {
        upload_i.clear ();
        upload_x.clear ();
        upload_x.clear ();
        upload_phi.clear ();

        upload->open (ULOAD, ULOAD_EXT, ULOAD_HEAD, "\t", nu::READ);                                // Opening data log file...

        while(!upload->eof ())
        {
          upload->read (&upload_i, &upload_x, &upload_y, &upload_phi);
        }

        upload->close (nu::READ);

        // Setting theta for all nodes:
        for(i = 0; i < nodes; i++)
        {
          phi->data[i]     = upload_phi[i];                                                         // Setting initial theta...
          phi_int->data[i] = upload_phi[i];                                                         // Setting initial theta (intermediate value)...
        }

        cl->write (5);                                                                              // Updating theta...
        cl->write (6);                                                                              // Updating theta (intermediate)...
        cl->acquire ();                                                                             // Acquiring OpenCL kernel...
        cl->execute (K2, nu::WAIT);                                                                 // Executing OpenCL kernel...
        cl->release ();                                                                             // Releasing OpenCL kernel...

        savedata = false;                                                                           // Resetting savedata flag...
      }
    }

    if(savedata)
    {
      // Downloading data:
      cl->read (5);                                                                                 // Reading theta...

      trial_index++;                                                                                // Updating trial_index...
      trial_text = std::string ("_#") + std::to_string (trial_index);                               // Updating trial text...
      time_index = 0;                                                                               // Resetting time_index...

      download->open (DLOAD + timestamp + trial_text, DLOAD_EXT, DLOAD_HEAD, "\t", nu::WRITE);      // Opening data log file...
      download->write ("#index");                                                                   // Logging header...
      download->write ("#x");                                                                       // Logging header...
      download->write ("#y");                                                                       // Logging header...
      download->write ("#phi(x,y)");                                                                // Logging header...
      download->endline ();                                                                         // Logging header...

      for(i = 0; i < nodes; i++)
      {
        download->write (vacuum->node[i]);                                                          // Logging node index...
        download->write (vacuum->node_coordinates[i].x);                                            // Logging node x-coordinate...
        download->write (vacuum->node_coordinates[i].y);                                            // Logging node y-coordinate...
        download->write (phi->data[i]);                                                             // Logging theta(x,y)...
        download->endline ();                                                                       // Ending log line...
      }

      download->close (nu::WRITE);                                                                  // Closing data download file...

      // Resetting theta for all nodes:
      for(i = 0; i < nodes; i++)
      {
        phi->data[i]     = upload_phi[i];                                                           // Setting initial theta...
        phi_int->data[i] = upload_phi[i];                                                           // Setting initial theta (intermediate value)...
      }

      cl->write (5);                                                                                // Updating theta...
      cl->write (6);                                                                                // Updating theta (intermediate)...
      cl->acquire ();                                                                               // Acquiring OpenCL kernel...
      cl->execute (K2, nu::WAIT);                                                                   // Executing OpenCL kernel...
      cl->release ();                                                                               // Releasing OpenCL kernel...

      savedata = false;                                                                             // Resetting savedata flag...
    }

    hud->finish ();                                                                                 // Finishing window...

    hud->end ();                                                                                    // Ending HUD...

    gl->end ();                                                                                     // Ending gl...
    cl->get_toc ();                                                                                 // Getting "toc" [us]...
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////// CLOSING DATA LOG FILE //////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  log->close (nu::WRITE);                                                                           // Closing data log file...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////// CLEANUP ////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  delete cl;                                                                                        // Deleting OpenCL context...
  delete gl;                                                                                        // Deleting OpenGL context...
  delete hud;                                                                                       // Deleting HUD context...
  delete S;                                                                                         // Deleting shader...
  delete color;                                                                                     // Deleting color data...
  delete position;                                                                                  // Deleting position data...
  delete central;                                                                                   // Deleting centrals...
  delete neighbour;                                                                                 // Deleting neighbours...
  delete offset;                                                                                    // Deleting offset...
  delete phi;                                                                                       // Deleting phi...
  delete phi_int;                                                                                   // Deleting phi (intermediate)...
  delete state_phi;                                                                                 // Deleting random generator state...
  delete state_threshold;                                                                           // Deleting random generator state...
  delete phi_row_sum;                                                                               // Deleting phi row summation.
  delete phi2_row_sum;                                                                              // Deleting phi square row summation.
  delete m_overflow;                                                                                // Deleting rejection sampling overflow...
  delete m_overflow_sum;                                                                            // Deleting rejection sampling overflow sum...
  delete parameter;                                                                                 // Deleting all parameters...
  delete K0;                                                                                        // Deleting OpenCL kernel...
  delete K1;                                                                                        // Deleting OpenCL kernel...
  delete K2;                                                                                        // Deleting OpenCL kernel...
  delete K3;                                                                                        // Deleting OpenCL kernel...
  delete vacuum;                                                                                    // Deleting vacuum mesh...
  delete log;                                                                                       // Deleting log file object...
  delete download;                                                                                  // Deleting download file object...
  delete upload;                                                                                    // Deleting upload file object...

  return 0;
}
